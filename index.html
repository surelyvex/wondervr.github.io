<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Geometry Dash</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #000;
  overflow: hidden;
  font-family: 'Segoe UI', Arial, sans-serif;
  user-select: none;
  -webkit-user-select: none;
}

canvas {
  display: block;
}

#ui-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  pointer-events: none;
  z-index: 10;
}

#attempt-counter {
  position: fixed;
  top: 18px; left: 50%;
  transform: translateX(-50%);
  color: rgba(255,255,255,0.5);
  font-size: 16px;
  z-index: 11;
  pointer-events: none;
  text-shadow: 0 0 10px rgba(0,0,0,0.8);
}

#progress-bar-container {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 4px;
  background: rgba(255,255,255,0.08);
  z-index: 11;
}

#progress-bar {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg, #00ff88, #00ccff);
  transition: width 0.1s linear;
  box-shadow: 0 0 10px rgba(0,255,136,0.5);
}

#menu-screen {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 20;
  background: radial-gradient(ellipse at center, #1a0a3e 0%, #0a0014 70%);
}

#menu-screen h1 {
  font-size: clamp(36px, 8vw, 72px);
  font-weight: 900;
  color: #fff;
  text-shadow: 0 0 30px rgba(0,200,255,0.6), 0 0 60px rgba(0,200,255,0.3);
  margin-bottom: 8px;
  letter-spacing: 2px;
}

#menu-screen .subtitle {
  color: rgba(255,255,255,0.4);
  font-size: 14px;
  margin-bottom: 50px;
  letter-spacing: 4px;
  text-transform: uppercase;
}

.menu-btn {
  padding: 16px 48px;
  font-size: 18px;
  font-weight: 700;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  pointer-events: all;
  margin: 8px;
  text-transform: uppercase;
  letter-spacing: 2px;
  transition: transform 0.15s, box-shadow 0.15s;
}

.menu-btn:hover {
  transform: scale(1.05);
}

.menu-btn:active {
  transform: scale(0.97);
}

#play-btn {
  background: linear-gradient(135deg, #00cc66, #00aa88);
  color: #fff;
  box-shadow: 0 4px 30px rgba(0,204,102,0.4);
}

#play-btn:hover {
  box-shadow: 0 6px 40px rgba(0,204,102,0.6);
}

.level-select {
  display: flex;
  gap: 12px;
  margin-top: 20px;
  flex-wrap: wrap;
  justify-content: center;
  max-width: 500px;
}

.level-btn {
  width: 64px; height: 64px;
  border-radius: 12px;
  border: 2px solid rgba(255,255,255,0.15);
  background: rgba(255,255,255,0.05);
  color: #fff;
  font-size: 20px;
  font-weight: 700;
  cursor: pointer;
  pointer-events: all;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}

.level-btn:hover {
  border-color: #00ccff;
  background: rgba(0,204,255,0.1);
  box-shadow: 0 0 20px rgba(0,204,255,0.3);
  transform: scale(1.1);
}

.level-btn.selected {
  border-color: #00ff88;
  background: rgba(0,255,136,0.15);
  box-shadow: 0 0 25px rgba(0,255,136,0.4);
}

.level-label {
  color: rgba(255,255,255,0.35);
  font-size: 11px;
  margin-top: 16px;
  letter-spacing: 3px;
  text-transform: uppercase;
}

.level-difficulty {
  color: rgba(255,255,255,0.25);
  font-size: 11px;
  margin-top: 4px;
}

#death-screen {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 20;
  background: rgba(0,0,0,0.7);
}

#death-screen h2 {
  font-size: 36px;
  color: #fff;
  margin-bottom: 20px;
  text-shadow: 0 0 20px rgba(255,50,50,0.5);
}

#death-screen .progress-text {
  color: rgba(255,255,255,0.5);
  font-size: 16px;
  margin-bottom: 30px;
}

#win-screen {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  display: none;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 20;
  background: rgba(0,0,0,0.75);
}

#win-screen h2 {
  font-size: 48px;
  color: #00ff88;
  margin-bottom: 10px;
  text-shadow: 0 0 30px rgba(0,255,136,0.6);
}

#win-screen .stats {
  color: rgba(255,255,255,0.5);
  font-size: 14px;
  margin-bottom: 30px;
  text-align: center;
  line-height: 2;
}

.controls-hint {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: rgba(255,255,255,0.2);
  font-size: 12px;
  z-index: 11;
  pointer-events: none;
  letter-spacing: 2px;
}

#practice-toggle {
  position: fixed;
  top: 18px;
  right: 18px;
  z-index: 15;
  display: none;
  align-items: center;
  gap: 8px;
  color: rgba(255,255,255,0.4);
  font-size: 12px;
  cursor: pointer;
  pointer-events: all;
}

#practice-toggle input {
  cursor: pointer;
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="progress-bar-container" style="display:none;">
  <div id="progress-bar"></div>
</div>

<div id="attempt-counter" style="display:none;">Attempt 1</div>

<div id="menu-screen">
  <h1>GEOMETRY DASH</h1>
  <div class="subtitle">Click or Space to Jump</div>
  <button class="menu-btn" id="play-btn">PLAY</button>
  <div class="level-label">Select Level</div>
  <div class="level-select">
    <button class="level-btn selected" data-level="0">1</button>
    <button class="level-btn" data-level="1">2</button>
    <button class="level-btn" data-level="2">3</button>
    <button class="level-btn" data-level="3">4</button>
    <button class="level-btn" data-level="4">5</button>
  </div>
  <div class="level-difficulty" id="level-diff">Easy</div>
</div>

<div id="death-screen">
  <h2>YOU CRASHED!</h2>
  <div class="progress-text" id="death-progress">Progress: 0%</div>
  <button class="menu-btn" id="retry-btn" style="background:linear-gradient(135deg,#cc3333,#aa2222);color:#fff;box-shadow:0 4px 30px rgba(204,51,51,0.4);">RETRY</button>
  <button class="menu-btn" id="menu-btn-death" style="background:rgba(255,255,255,0.08);color:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.1);">MENU</button>
</div>

<div id="win-screen">
  <h2>LEVEL COMPLETE!</h2>
  <div class="stats" id="win-stats"></div>
  <button class="menu-btn" id="next-level-btn" style="background:linear-gradient(135deg,#00cc66,#00aa88);color:#fff;box-shadow:0 4px 30px rgba(0,204,102,0.4);">NEXT LEVEL</button>
  <button class="menu-btn" id="menu-btn-win" style="background:rgba(255,255,255,0.08);color:rgba(255,255,255,0.6);border:1px solid rgba(255,255,255,0.1);">MENU</button>
</div>

<label id="practice-toggle">
  <input type="checkbox" id="practice-mode"> Practice Mode
</label>

<div class="controls-hint" id="controls-hint">SPACE / CLICK / TAP TO JUMP &mdash; HOLD FOR SHIP MODE</div>

<script>
// ─── Canvas Setup ───────────────────────────────────────────
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// ─── Audio System (procedural) ──────────────────────────────
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;

function ensureAudio() {
  if (!audioCtx) audioCtx = new AudioCtx();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function playJumpSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'square';
  osc.frequency.setValueAtTime(600, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.08);
  gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.15);
}

function playDeathSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'sawtooth';
  osc.frequency.setValueAtTime(400, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(80, audioCtx.currentTime + 0.4);
  gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.4);
}

function playWinSound() {
  if (!audioCtx) return;
  const notes = [523, 659, 784, 1047];
  notes.forEach((freq, i) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'square';
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime + i * 0.12);
    gain.gain.setValueAtTime(0.06, audioCtx.currentTime + i * 0.12);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.12 + 0.3);
    osc.start(audioCtx.currentTime + i * 0.12);
    osc.stop(audioCtx.currentTime + i * 0.12 + 0.3);
  });
}

function playPortalSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'sine';
  osc.frequency.setValueAtTime(300, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.2);
  gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.25);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.25);
}

function playOrbSound() {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.type = 'triangle';
  osc.frequency.setValueAtTime(800, audioCtx.currentTime);
  osc.frequency.exponentialRampToValueAtTime(1400, audioCtx.currentTime + 0.1);
  gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.15);
}

// Background music using oscillators
let bgMusicNodes = [];
function startBgMusic(bpm) {
  stopBgMusic();
  if (!audioCtx) return;
  const beatInterval = 60 / bpm;

  // Bass line
  const bassOsc = audioCtx.createOscillator();
  const bassGain = audioCtx.createGain();
  const bassFilter = audioCtx.createBiquadFilter();
  bassOsc.type = 'sawtooth';
  bassOsc.frequency.value = 55;
  bassFilter.type = 'lowpass';
  bassFilter.frequency.value = 200;
  bassGain.gain.value = 0.06;
  bassOsc.connect(bassFilter);
  bassFilter.connect(bassGain);
  bassGain.connect(audioCtx.destination);
  bassOsc.start();
  bgMusicNodes.push(bassOsc, bassGain, bassFilter);

  // Kick drum simulation
  function scheduleKick(time) {
    const kickOsc = audioCtx.createOscillator();
    const kickGain = audioCtx.createGain();
    kickOsc.type = 'sine';
    kickOsc.frequency.setValueAtTime(150, time);
    kickOsc.frequency.exponentialRampToValueAtTime(30, time + 0.08);
    kickGain.gain.setValueAtTime(0.15, time);
    kickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.12);
    kickOsc.connect(kickGain);
    kickGain.connect(audioCtx.destination);
    kickOsc.start(time);
    kickOsc.stop(time + 0.12);
  }

  let kickTime = audioCtx.currentTime;
  const kickInterval = setInterval(() => {
    if (audioCtx.state === 'closed') { clearInterval(kickInterval); return; }
    kickTime = audioCtx.currentTime + 0.05;
    scheduleKick(kickTime);
  }, beatInterval * 1000);
  bgMusicNodes.push({ stop: () => clearInterval(kickInterval), disconnect: () => {} });
}

function stopBgMusic() {
  bgMusicNodes.forEach(node => {
    try { node.stop && node.stop(); } catch(e) {}
    try { node.disconnect && node.disconnect(); } catch(e) {}
  });
  bgMusicNodes = [];
}

// ─── Game Constants ─────────────────────────────────────────
const BLOCK_SIZE = 40;
const GRAVITY = 0.9;
const JUMP_FORCE = -12;
const SHIP_GRAVITY = 0.4;
const SHIP_LIFT = -0.7;
const WAVE_SPEED = 8;

// ─── Color Themes per Level ─────────────────────────────────
const THEMES = [
  { bg1: '#0a1628', bg2: '#0d2847', ground: '#1a3a5c', groundLine: '#2a5a8c', accent: '#00ccff', player: '#00ff88', spike: '#ffffff', block: '#1e4a7a', name: 'Stereo Madness', difficulty: 'Easy', bpm: 140 },
  { bg1: '#1a0a28', bg2: '#2d0d47', ground: '#3a1a5c', groundLine: '#5a2a8c', accent: '#cc44ff', player: '#ff44cc', spike: '#ffffff', block: '#4a1e7a', name: 'Back on Track', difficulty: 'Easy', bpm: 150 },
  { bg1: '#281a0a', bg2: '#472d0d', ground: '#5c3a1a', groundLine: '#8c5a2a', accent: '#ff8800', player: '#ffcc00', spike: '#ffffff', block: '#7a4a1e', name: 'Polargeist', difficulty: 'Normal', bpm: 160 },
  { bg1: '#0a2818', bg2: '#0d4728', ground: '#1a5c38', groundLine: '#2a8c58', accent: '#00ff66', player: '#88ff00', spike: '#ffffff', block: '#1e7a48', name: 'Dry Out', difficulty: 'Normal', bpm: 155 },
  { bg1: '#280a0a', bg2: '#470d0d', ground: '#5c1a1a', groundLine: '#8c2a2a', accent: '#ff2222', player: '#ff6644', spike: '#ffffff', block: '#7a1e1e', name: 'Base After Base', difficulty: 'Hard', bpm: 170 },
];

// ─── Obstacle Types ─────────────────────────────────────────
// 'S' = spike, 'B' = block, 'T' = tall block (2 high), 'P' = platform (floating),
// 'J' = jump pad, 'O' = jump orb, 'G' = gravity portal, 'H' = ship portal,
// 'C' = cube portal, 'W' = wave portal, '_' = gap, ' ' = empty column

// ─── Level Data ─────────────────────────────────────────────
// Each level is an array of obstacle descriptors
// {type, x_offset (in blocks from level start)}

function generateLevel(levelIndex) {
  const obstacles = [];
  const speed = 6 + levelIndex * 0.8;
  let x = 20; // starting gap in blocks

  const patterns = getLevelPatterns(levelIndex);

  patterns.forEach(pattern => {
    pattern.forEach(item => {
      obstacles.push({ ...item, x: (x + item.dx) * BLOCK_SIZE });
    });
    x += pattern.length > 0 ? Math.max(...pattern.map(i => i.dx)) + 4 : 4;
  });

  // End marker
  const totalLength = (x + 5) * BLOCK_SIZE;

  return { obstacles, speed, totalLength, theme: THEMES[levelIndex] };
}

function getLevelPatterns(level) {
  const P = []; // patterns array

  if (level === 0) {
    // Level 1: Easy - basic jumps and spikes
    // Gentle intro
    P.push([{ type: 'spike', dx: 0 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }]);
    P.push([{ type: 'spike', dx: 0 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'block', dx: 1, h: 1 }]);
    P.push([{ type: 'spike', dx: 0 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'spike', dx: 1 }, { type: 'block', dx: 2, h: 1 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'block', dx: 1, h: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'block', dx: 1, h: 2 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'spike', dx: 0 }]);
    P.push([{ type: 'jump_orb', dx: 0, oy: -3 }, { type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'block', dx: 0, h: 3 }]);
    P.push([{ type: 'spike', dx: 0 }]);
  } else if (level === 1) {
    // Level 2: More blocks and jump pads
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'block', dx: 1, h: 2 }]);
    P.push([{ type: 'spike', dx: 0 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'block', dx: 3, h: 3 }, { type: 'spike', dx: 4 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'block', dx: 1, h: 1 }, { type: 'spike', dx: 2 }, { type: 'block', dx: 3, h: 1 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }, { type: 'spike', dx: 4 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'block', dx: 1, h: 1 }, { type: 'block', dx: 2, h: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'gravity_portal', dx: 0 }]);
    P.push([{ type: 'ceiling_spike', dx: 2 }, { type: 'ceiling_spike', dx: 3 }]);
    P.push([{ type: 'gravity_portal', dx: 0 }]);
    P.push([{ type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'jump_orb', dx: 0, oy: -3 }, { type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'block', dx: 0, h: 3 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'block', dx: 2, h: 2 }, { type: 'spike', dx: 3 }, { type: 'spike', dx: 4 }]);
    P.push([{ type: 'spike', dx: 0 }]);
  } else if (level === 2) {
    // Level 3: Ship sections and complexity
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'block', dx: 1, h: 2 }, { type: 'block', dx: 2, h: 3 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'ship_portal', dx: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 2, oy: 4 }, { type: 'ship_block_bottom', dx: 2, oy: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 1, oy: 5 }, { type: 'ship_block_bottom', dx: 1, oy: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 1, oy: 3 }, { type: 'ship_block_bottom', dx: 1, oy: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 2, oy: 5 }]);
    P.push([{ type: 'ship_block_bottom', dx: 1, oy: 0 }, { type: 'ship_block_top', dx: 1, oy: 4 }]);
    P.push([{ type: 'cube_portal', dx: 0 }]);
    P.push([{ type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'spike', dx: 1 }, { type: 'block', dx: 2, h: 2 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'spike', dx: 3 }, { type: 'spike', dx: 4 }]);
    P.push([{ type: 'block', dx: 0, h: 3 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'block', dx: 1, h: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'jump_orb', dx: 0, oy: -3 }, { type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'spike', dx: 0 }]);
  } else if (level === 3) {
    // Level 4: Wave mode and mixed
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'block', dx: 2, h: 3 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'block', dx: 1, h: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'wave_portal', dx: 0 }]);
    P.push([{ type: 'wave_ceiling', dx: 1, oy: 3 }, { type: 'wave_floor', dx: 3, oy: 0 }]);
    P.push([{ type: 'wave_ceiling', dx: 1, oy: 4 }, { type: 'wave_floor', dx: 2, oy: 0 }]);
    P.push([{ type: 'wave_floor', dx: 1, oy: 0 }, { type: 'wave_ceiling', dx: 2, oy: 3 }]);
    P.push([{ type: 'wave_ceiling', dx: 1, oy: 5 }]);
    P.push([{ type: 'wave_floor', dx: 1, oy: 0 }, { type: 'wave_ceiling', dx: 1, oy: 4 }]);
    P.push([{ type: 'cube_portal', dx: 0 }]);
    P.push([{ type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'gravity_portal', dx: 0 }]);
    P.push([{ type: 'ceiling_spike', dx: 1 }, { type: 'ceiling_spike', dx: 2 }]);
    P.push([{ type: 'gravity_portal', dx: 0 }]);
    P.push([{ type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'block', dx: 1, h: 3 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }, { type: 'spike', dx: 4 }, { type: 'spike', dx: 5 }]);
    P.push([{ type: 'block', dx: 0, h: 1 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'spike', dx: 0 }]);
  } else {
    // Level 5: Hard - everything combined
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'block', dx: 0, h: 3 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'block', dx: 1, h: 2 }, { type: 'spike', dx: 2 }, { type: 'block', dx: 3, h: 1 }]);
    P.push([{ type: 'jump_pad', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }, { type: 'block', dx: 3, h: 3 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }]);
    P.push([{ type: 'ship_portal', dx: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 1, oy: 3 }, { type: 'ship_block_bottom', dx: 1, oy: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 1, oy: 4 }, { type: 'ship_block_bottom', dx: 2, oy: 0 }]);
    P.push([{ type: 'ship_block_top', dx: 1, oy: 3 }]);
    P.push([{ type: 'ship_block_bottom', dx: 1, oy: 0 }, { type: 'ship_block_top', dx: 1, oy: 4 }]);
    P.push([{ type: 'cube_portal', dx: 0 }]);
    P.push([{ type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'block', dx: 1, h: 3 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'jump_orb', dx: 0, oy: -3 }, { type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }, { type: 'spike', dx: 3 }, { type: 'spike', dx: 4 }]);
    P.push([{ type: 'wave_portal', dx: 0 }]);
    P.push([{ type: 'wave_ceiling', dx: 1, oy: 3 }, { type: 'wave_floor', dx: 2, oy: 0 }]);
    P.push([{ type: 'wave_floor', dx: 1, oy: 0 }, { type: 'wave_ceiling', dx: 2, oy: 4 }]);
    P.push([{ type: 'wave_ceiling', dx: 1, oy: 3 }, { type: 'wave_floor', dx: 1, oy: 0 }]);
    P.push([{ type: 'cube_portal', dx: 0 }]);
    P.push([{ type: 'gravity_portal', dx: 0 }]);
    P.push([{ type: 'ceiling_spike', dx: 1 }, { type: 'ceiling_spike', dx: 2 }, { type: 'ceiling_spike', dx: 3 }]);
    P.push([{ type: 'gravity_portal', dx: 0 }]);
    P.push([{ type: 'block', dx: 0, h: 2 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'block', dx: 1, h: 3 }]);
    P.push([{ type: 'spike', dx: 0 }, { type: 'spike', dx: 1 }, { type: 'spike', dx: 2 }]);
  }

  return P;
}

// ─── Particle System ────────────────────────────────────────
class Particle {
  constructor(x, y, color, vx, vy, life, size) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.vx = vx || (Math.random() - 0.5) * 8;
    this.vy = vy || (Math.random() - 0.5) * 8;
    this.life = life || 1;
    this.maxLife = this.life;
    this.size = size || Math.random() * 6 + 2;
    this.rotation = Math.random() * Math.PI * 2;
    this.rotSpeed = (Math.random() - 0.5) * 0.3;
  }

  update(dt) {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.15;
    this.life -= dt;
    this.rotation += this.rotSpeed;
  }

  draw(ctx) {
    const alpha = Math.max(0, this.life / this.maxLife);
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.rotation);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
    ctx.globalAlpha = 1;
    ctx.restore();
  }
}

// ─── Game State ─────────────────────────────────────────────
let state = 'menu'; // menu, playing, dead, won
let selectedLevel = 0;
let attempts = 1;
let totalAttempts = {};
let level = null;
let cameraX = 0;
let groundY = 0;
let particles = [];
let trailParticles = [];
let bgStars = [];
let screenShake = 0;
let deathProgress = 0;
let practiceMode = false;
let checkpointX = -1;
let lastTimestamp = 0;

// Player state
const player = {
  x: 0, y: 0,
  vy: 0,
  width: BLOCK_SIZE - 4,
  height: BLOCK_SIZE - 4,
  rotation: 0,
  onGround: false,
  mode: 'cube', // cube, ship, wave
  gravityFlipped: false,
  dead: false,
  jumpBuffered: false,
};

// Input
let inputDown = false;
let inputJustPressed = false;

// ─── Initialize Stars ───────────────────────────────────────
function initStars() {
  bgStars = [];
  for (let i = 0; i < 120; i++) {
    bgStars.push({
      x: Math.random() * 3000,
      y: Math.random() * canvas.height,
      size: Math.random() * 2 + 0.5,
      speed: Math.random() * 0.5 + 0.1,
      brightness: Math.random(),
    });
  }
}
initStars();

// ─── Level Setup ────────────────────────────────────────────
function startLevel(levelIndex) {
  ensureAudio();
  selectedLevel = levelIndex;
  level = generateLevel(levelIndex);
  groundY = canvas.height - 80;
  player.x = 5 * BLOCK_SIZE;
  player.y = groundY - player.height;
  player.vy = 0;
  player.rotation = 0;
  player.onGround = false;
  player.mode = 'cube';
  player.gravityFlipped = false;
  player.dead = false;
  cameraX = 0;
  particles = [];
  trailParticles = [];
  screenShake = 0;
  checkpointX = -1;

  if (!totalAttempts[levelIndex]) totalAttempts[levelIndex] = 0;
  totalAttempts[levelIndex]++;
  attempts = totalAttempts[levelIndex];

  document.getElementById('attempt-counter').textContent = `Attempt ${attempts}`;
  document.getElementById('attempt-counter').style.display = 'block';
  document.getElementById('progress-bar-container').style.display = 'block';
  document.getElementById('practice-toggle').style.display = 'flex';
  document.getElementById('controls-hint').style.display = 'block';
  document.getElementById('menu-screen').style.display = 'none';
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('win-screen').style.display = 'none';

  state = 'playing';
  startBgMusic(level.theme.bpm);
}

function die() {
  if (player.dead) return;
  player.dead = true;
  state = 'dead';
  screenShake = 12;
  stopBgMusic();
  playDeathSound();

  // Death particles
  const theme = level.theme;
  for (let i = 0; i < 30; i++) {
    particles.push(new Particle(
      player.x + player.width / 2 - cameraX + canvas.width * 0.15,
      player.y + player.height / 2,
      theme.player,
      (Math.random() - 0.5) * 16,
      (Math.random() - 0.5) * 16,
      1.2,
      Math.random() * 8 + 3
    ));
  }

  deathProgress = Math.floor((player.x / level.totalLength) * 100);

  setTimeout(() => {
    document.getElementById('death-screen').style.display = 'flex';
    document.getElementById('death-progress').textContent = `Progress: ${deathProgress}%`;
  }, 600);
}

function win() {
  state = 'won';
  stopBgMusic();
  playWinSound();

  // Win particles
  for (let i = 0; i < 60; i++) {
    particles.push(new Particle(
      canvas.width / 2 + (Math.random() - 0.5) * 200,
      canvas.height / 2 + (Math.random() - 0.5) * 200,
      ['#00ff88', '#00ccff', '#ffcc00', '#ff44cc'][Math.floor(Math.random() * 4)],
      (Math.random() - 0.5) * 10,
      (Math.random() - 1) * 10,
      2,
      Math.random() * 8 + 3
    ));
  }

  document.getElementById('win-screen').style.display = 'flex';
  document.getElementById('win-stats').innerHTML = `Attempts: ${attempts}<br>Level: ${level.theme.name}`;
}

// ─── Input Handling ─────────────────────────────────────────
function onInputDown(e) {
  if (e) e.preventDefault();
  inputDown = true;
  inputJustPressed = true;
}

function onInputUp(e) {
  if (e) e.preventDefault();
  inputDown = false;
}

window.addEventListener('keydown', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
    e.preventDefault();
    if (!e.repeat) {
      onInputDown();
    }
  }
});

window.addEventListener('keyup', (e) => {
  if (e.code === 'Space' || e.code === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
    e.preventDefault();
    onInputUp();
  }
});

canvas.addEventListener('mousedown', onInputDown);
canvas.addEventListener('mouseup', onInputUp);
canvas.addEventListener('touchstart', onInputDown, { passive: false });
canvas.addEventListener('touchend', onInputUp, { passive: false });

// ─── UI Buttons ─────────────────────────────────────────────
document.getElementById('play-btn').addEventListener('click', () => {
  startLevel(selectedLevel);
});

document.querySelectorAll('.level-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    selectedLevel = parseInt(btn.dataset.level);
    document.getElementById('level-diff').textContent = THEMES[selectedLevel].difficulty + ' - ' + THEMES[selectedLevel].name;
  });
});

document.getElementById('retry-btn').addEventListener('click', () => {
  startLevel(selectedLevel);
});

document.getElementById('menu-btn-death').addEventListener('click', () => {
  state = 'menu';
  document.getElementById('death-screen').style.display = 'none';
  document.getElementById('menu-screen').style.display = 'flex';
  document.getElementById('attempt-counter').style.display = 'none';
  document.getElementById('progress-bar-container').style.display = 'none';
  document.getElementById('practice-toggle').style.display = 'none';
  stopBgMusic();
});

document.getElementById('next-level-btn').addEventListener('click', () => {
  const next = Math.min(selectedLevel + 1, THEMES.length - 1);
  selectedLevel = next;
  startLevel(next);
});

document.getElementById('menu-btn-win').addEventListener('click', () => {
  state = 'menu';
  document.getElementById('win-screen').style.display = 'none';
  document.getElementById('menu-screen').style.display = 'flex';
  document.getElementById('attempt-counter').style.display = 'none';
  document.getElementById('progress-bar-container').style.display = 'none';
  document.getElementById('practice-toggle').style.display = 'none';
  stopBgMusic();
});

document.getElementById('practice-mode').addEventListener('change', (e) => {
  practiceMode = e.target.checked;
});

// ─── Collision Detection ────────────────────────────────────
function getObstacleRect(obs) {
  const bs = BLOCK_SIZE;
  switch (obs.type) {
    case 'block':
      return { x: obs.x, y: groundY - (obs.h || 1) * bs, w: bs, h: (obs.h || 1) * bs };
    case 'spike':
      return { x: obs.x + 8, y: groundY - bs + 8, w: bs - 16, h: bs - 8, spike: true };
    case 'ceiling_spike':
      return { x: obs.x + 8, y: 0, w: bs - 16, h: bs - 8, spike: true };
    case 'jump_pad':
      return { x: obs.x, y: groundY - bs / 3, w: bs, h: bs / 3, jumpPad: true };
    case 'jump_orb':
      return { x: obs.x + 8, y: groundY + (obs.oy || -3) * bs + 8, w: bs - 16, h: bs - 16, jumpOrb: true };
    case 'gravity_portal':
      return { x: obs.x, y: groundY - 4 * bs, w: bs, h: 4 * bs, portal: 'gravity' };
    case 'ship_portal':
      return { x: obs.x, y: groundY - 4 * bs, w: bs, h: 4 * bs, portal: 'ship' };
    case 'cube_portal':
      return { x: obs.x, y: groundY - 4 * bs, w: bs, h: 4 * bs, portal: 'cube' };
    case 'wave_portal':
      return { x: obs.x, y: groundY - 4 * bs, w: bs, h: 4 * bs, portal: 'wave' };
    case 'ship_block_top':
      return { x: obs.x, y: 0, w: bs * 2, h: (obs.oy || 3) * bs };
    case 'ship_block_bottom':
      return { x: obs.x, y: groundY - (obs.oy || 0) * bs - bs * 2, w: bs * 2, h: bs * 2 + (obs.oy || 0) * bs + 80 };
    case 'wave_ceiling':
      return { x: obs.x, y: 0, w: bs, h: (obs.oy || 3) * bs };
    case 'wave_floor':
      return { x: obs.x, y: groundY - bs, w: bs, h: bs + 80 };
    default:
      return { x: obs.x, y: groundY - bs, w: bs, h: bs };
  }
}

function rectsOverlap(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// ─── Update ─────────────────────────────────────────────────
function update(dt) {
  if (state !== 'playing') {
    inputJustPressed = false;
    // Still update particles
    updateParticles(dt);
    return;
  }

  const speed = level.speed;
  const theme = level.theme;

  // Move player forward (camera moves instead)
  player.x += speed;
  cameraX = player.x - canvas.width * 0.15;

  // Progress
  const progress = Math.min(player.x / level.totalLength, 1);
  document.getElementById('progress-bar').style.width = (progress * 100) + '%';

  // Check win
  if (player.x >= level.totalLength) {
    win();
    inputJustPressed = false;
    return;
  }

  // Gravity
  const gravDir = player.gravityFlipped ? -1 : 1;

  if (player.mode === 'cube') {
    player.vy += GRAVITY * gravDir;
    player.y += player.vy;

    // Ground/ceiling collision
    if (!player.gravityFlipped) {
      if (player.y + player.height >= groundY) {
        player.y = groundY - player.height;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }
      if (player.y < 0) {
        player.y = 0;
        player.vy = 0;
      }
    } else {
      if (player.y <= 0) {
        player.y = 0;
        player.vy = 0;
        player.onGround = true;
      } else {
        player.onGround = false;
      }
      if (player.y + player.height > groundY) {
        player.y = groundY - player.height;
        player.vy = 0;
      }
    }

    // Jump
    if (inputJustPressed && player.onGround) {
      player.vy = JUMP_FORCE * gravDir;
      player.onGround = false;
      playJumpSound();
    }

    // Rotation
    if (!player.onGround) {
      player.rotation += 5 * gravDir * (dt / 16.67);
    } else {
      player.rotation = Math.round(player.rotation / (Math.PI / 2)) * (Math.PI / 2);
    }

  } else if (player.mode === 'ship') {
    // Ship mode - hold to fly up
    if (inputDown) {
      player.vy += (player.gravityFlipped ? SHIP_GRAVITY : -SHIP_GRAVITY) * 1.5;
    } else {
      player.vy += SHIP_GRAVITY * gravDir;
    }

    player.vy = Math.max(-8, Math.min(8, player.vy));
    player.y += player.vy;

    // Boundaries
    if (player.y + player.height >= groundY) {
      player.y = groundY - player.height;
      player.vy = 0;
    }
    if (player.y < 0) {
      player.y = 0;
      player.vy = 0;
    }

    // Ship rotation follows velocity
    player.rotation = player.vy * 0.05;

  } else if (player.mode === 'wave') {
    // Wave mode - hold to go up diagonally, release to go down
    if (inputDown) {
      player.vy = -WAVE_SPEED * gravDir;
    } else {
      player.vy = WAVE_SPEED * gravDir;
    }

    player.y += player.vy * (dt / 16.67);

    // Boundaries
    if (player.y + player.height >= groundY) {
      player.y = groundY - player.height;
      die();
    }
    if (player.y < 0) {
      player.y = 0;
      die();
    }

    player.rotation = player.vy > 0 ? Math.PI / 4 : -Math.PI / 4;
  }

  // Obstacle collision
  const playerRect = { x: player.x, y: player.y, w: player.width, h: player.height };

  for (const obs of level.obstacles) {
    const rect = getObstacleRect(obs);
    if (!rectsOverlap(playerRect, rect)) continue;

    if (rect.portal) {
      if (!obs.triggered) {
        obs.triggered = true;
        playPortalSound();
        if (rect.portal === 'gravity') {
          player.gravityFlipped = !player.gravityFlipped;
        } else if (rect.portal === 'ship') {
          player.mode = 'ship';
        } else if (rect.portal === 'cube') {
          player.mode = 'cube';
        } else if (rect.portal === 'wave') {
          player.mode = 'wave';
        }
      }
      continue;
    }

    if (rect.jumpPad) {
      if (!obs.triggered) {
        obs.triggered = true;
        player.vy = JUMP_FORCE * 1.8 * (player.gravityFlipped ? -1 : 1);
        player.onGround = false;
        playOrbSound();
        // Pad particles
        for (let i = 0; i < 8; i++) {
          particles.push(new Particle(
            rect.x + rect.w / 2 - cameraX + canvas.width * 0.15,
            rect.y,
            '#ffcc00',
            (Math.random() - 0.5) * 6,
            -Math.random() * 8,
            0.6
          ));
        }
      }
      continue;
    }

    if (rect.jumpOrb) {
      if (inputJustPressed && !obs.triggered) {
        obs.triggered = true;
        player.vy = JUMP_FORCE * 1.3 * (player.gravityFlipped ? -1 : 1);
        player.onGround = false;
        playOrbSound();
        for (let i = 0; i < 8; i++) {
          particles.push(new Particle(
            rect.x + rect.w / 2 - cameraX + canvas.width * 0.15,
            rect.y + rect.h / 2,
            '#00ccff',
            (Math.random() - 0.5) * 6,
            (Math.random() - 0.5) * 6,
            0.6
          ));
        }
      }
      continue;
    }

    if (rect.spike) {
      die();
      break;
    }

    // Solid block collision
    // Check if landing on top
    const prevBottom = player.y + player.height - player.vy;
    if (!player.gravityFlipped && player.vy >= 0 && prevBottom <= rect.y + 2) {
      player.y = rect.y - player.height;
      player.vy = 0;
      player.onGround = true;
    } else if (player.gravityFlipped && player.vy <= 0 && player.y - player.vy >= rect.y + rect.h - 2) {
      player.y = rect.y + rect.h;
      player.vy = 0;
      player.onGround = true;
    } else {
      // Side or bottom collision = death
      die();
      break;
    }
  }

  // Trail particles
  if (Math.random() < 0.5) {
    trailParticles.push(new Particle(
      player.x + player.width / 2 - cameraX + canvas.width * 0.15,
      player.y + player.height / 2 + (Math.random() - 0.5) * 10,
      theme.player,
      -Math.random() * 2 - 1,
      (Math.random() - 0.5) * 2,
      0.4,
      Math.random() * 4 + 1
    ));
  }

  updateParticles(dt);
  inputJustPressed = false;

  // Screen shake decay
  if (screenShake > 0) screenShake *= 0.85;
}

function updateParticles(dt) {
  const dtNorm = dt / 16.67;
  particles = particles.filter(p => { p.update(dtNorm * 0.016); return p.life > 0; });
  trailParticles = trailParticles.filter(p => { p.update(dtNorm * 0.016); return p.life > 0; });
}

// ─── Drawing ────────────────────────────────────────────────
function draw() {
  const W = canvas.width;
  const H = canvas.height;
  ctx.clearRect(0, 0, W, H);

  if (state === 'menu') {
    // Menu background is handled by CSS
    return;
  }

  const theme = level.theme;

  // Screen shake offset
  const shakeX = screenShake > 0.5 ? (Math.random() - 0.5) * screenShake : 0;
  const shakeY = screenShake > 0.5 ? (Math.random() - 0.5) * screenShake : 0;
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Background gradient
  const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
  bgGrad.addColorStop(0, theme.bg1);
  bgGrad.addColorStop(1, theme.bg2);
  ctx.fillStyle = bgGrad;
  ctx.fillRect(0, 0, W, H);

  // Stars
  ctx.save();
  bgStars.forEach(star => {
    const sx = ((star.x - cameraX * star.speed * 0.05) % W + W) % W;
    const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.002 + star.brightness * 10);
    ctx.globalAlpha = star.brightness * 0.4 * pulse;
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(sx, star.y, star.size, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
  ctx.restore();

  // Background decorative blocks (parallax)
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = theme.accent;
  for (let i = 0; i < 20; i++) {
    const bx = ((i * 200 - cameraX * 0.2) % (W + 400)) - 200;
    const by = 100 + Math.sin(i * 1.5) * 150;
    const bs = 30 + Math.sin(i * 2.3) * 20;
    ctx.save();
    ctx.translate(bx + bs / 2, by + bs / 2);
    ctx.rotate(Date.now() * 0.0005 + i);
    ctx.fillRect(-bs / 2, -bs / 2, bs, bs);
    ctx.restore();
  }
  ctx.globalAlpha = 1;

  // Ground
  ctx.fillStyle = theme.ground;
  ctx.fillRect(0, groundY, W, H - groundY);

  // Ground line
  ctx.strokeStyle = theme.groundLine;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(0, groundY);
  ctx.lineTo(W, groundY);
  ctx.stroke();

  // Ground grid pattern
  ctx.strokeStyle = theme.groundLine;
  ctx.lineWidth = 0.5;
  ctx.globalAlpha = 0.3;
  const gridSize = BLOCK_SIZE;
  const gridOffset = (-cameraX % gridSize + gridSize) % gridSize;
  for (let gx = gridOffset - gridSize; gx < W + gridSize; gx += gridSize) {
    ctx.beginPath();
    ctx.moveTo(gx, groundY);
    ctx.lineTo(gx, H);
    ctx.stroke();
  }
  for (let gy = groundY; gy < H; gy += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, gy);
    ctx.lineTo(W, gy);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // Draw obstacles
  const viewLeft = cameraX - 200;
  const viewRight = cameraX + W + 200;

  for (const obs of level.obstacles) {
    if (obs.x < viewLeft - BLOCK_SIZE * 4 || obs.x > viewRight) continue;

    const screenX = obs.x - cameraX + W * 0.15 - player.x + cameraX;
    const drawX = obs.x - cameraX + W * 0.15 - player.x + cameraX;
    const ox = obs.x - cameraX;

    drawObstacle(obs, ox, theme);
  }

  // Draw player
  if (!player.dead) {
    drawPlayer(theme);
  }

  // Trail particles
  trailParticles.forEach(p => p.draw(ctx));

  // Particles
  particles.forEach(p => p.draw(ctx));

  ctx.restore();
}

function drawObstacle(obs, baseX, theme) {
  const bs = BLOCK_SIZE;
  const sx = obs.x - cameraX + canvas.width * 0.15 - player.x + cameraX;
  const screenX = obs.x - player.x + canvas.width * 0.15;

  switch (obs.type) {
    case 'spike': {
      const x = screenX;
      const y = groundY;
      ctx.fillStyle = theme.spike;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x + bs / 2, y - bs);
      ctx.lineTo(x + bs, y);
      ctx.closePath();
      ctx.fill();
      // Glow
      ctx.shadowColor = theme.accent;
      ctx.shadowBlur = 8;
      ctx.strokeStyle = theme.accent;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.shadowBlur = 0;
      break;
    }

    case 'ceiling_spike': {
      const x = screenX;
      ctx.fillStyle = theme.spike;
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x + bs / 2, bs);
      ctx.lineTo(x + bs, 0);
      ctx.closePath();
      ctx.fill();
      ctx.shadowColor = theme.accent;
      ctx.shadowBlur = 8;
      ctx.strokeStyle = theme.accent;
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.shadowBlur = 0;
      break;
    }

    case 'block': {
      const x = screenX;
      const h = (obs.h || 1) * bs;
      const y = groundY - h;
      // Block body
      ctx.fillStyle = theme.block;
      ctx.fillRect(x, y, bs, h);
      // Block outline glow
      ctx.strokeStyle = theme.accent;
      ctx.lineWidth = 1.5;
      ctx.shadowColor = theme.accent;
      ctx.shadowBlur = 6;
      ctx.strokeRect(x, y, bs, h);
      ctx.shadowBlur = 0;
      // Inner pattern
      ctx.strokeStyle = theme.accent;
      ctx.globalAlpha = 0.15;
      ctx.lineWidth = 1;
      for (let i = 0; i < (obs.h || 1); i++) {
        ctx.strokeRect(x + 4, y + i * bs + 4, bs - 8, bs - 8);
        ctx.beginPath();
        ctx.moveTo(x + 4, y + i * bs + 4);
        ctx.lineTo(x + bs - 4, y + (i + 1) * bs - 4);
        ctx.moveTo(x + bs - 4, y + i * bs + 4);
        ctx.lineTo(x + 4, y + (i + 1) * bs - 4);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      break;
    }

    case 'jump_pad': {
      const x = screenX;
      const y = groundY - bs / 3;
      // Pad
      ctx.fillStyle = '#ffcc00';
      ctx.shadowColor = '#ffcc00';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.moveTo(x, y + bs / 3);
      ctx.lineTo(x + bs / 2, y);
      ctx.lineTo(x + bs, y + bs / 3);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      // Arrow
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + bs / 2, y + bs / 4);
      ctx.lineTo(x + bs / 2, y + 4);
      ctx.moveTo(x + bs / 2 - 5, y + 10);
      ctx.lineTo(x + bs / 2, y + 4);
      ctx.lineTo(x + bs / 2 + 5, y + 10);
      ctx.stroke();
      break;
    }

    case 'jump_orb': {
      const x = screenX + bs / 2;
      const y = groundY + (obs.oy || -3) * bs + bs / 2;
      const pulse = 0.8 + 0.2 * Math.sin(Date.now() * 0.008);
      // Outer glow
      ctx.fillStyle = 'rgba(0,204,255,0.15)';
      ctx.beginPath();
      ctx.arc(x, y, bs * 0.6 * pulse, 0, Math.PI * 2);
      ctx.fill();
      // Orb
      const orbGrad = ctx.createRadialGradient(x, y, 0, x, y, bs * 0.35);
      orbGrad.addColorStop(0, '#ffffff');
      orbGrad.addColorStop(0.5, '#00ccff');
      orbGrad.addColorStop(1, '#0066aa');
      ctx.fillStyle = orbGrad;
      ctx.shadowColor = '#00ccff';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(x, y, bs * 0.35 * pulse, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      break;
    }

    case 'gravity_portal': {
      const x = screenX;
      const y = groundY - 4 * bs;
      drawPortal(x, y, bs, 4 * bs, '#ffcc00', '#00ccff');
      break;
    }

    case 'ship_portal': {
      const x = screenX;
      const y = groundY - 4 * bs;
      drawPortal(x, y, bs, 4 * bs, '#ff44cc', '#ff88ee');
      break;
    }

    case 'cube_portal': {
      const x = screenX;
      const y = groundY - 4 * bs;
      drawPortal(x, y, bs, 4 * bs, '#00ff88', '#88ffcc');
      break;
    }

    case 'wave_portal': {
      const x = screenX;
      const y = groundY - 4 * bs;
      drawPortal(x, y, bs, 4 * bs, '#ff8800', '#ffcc44');
      break;
    }

    case 'ship_block_top':
    case 'wave_ceiling': {
      const x = screenX;
      const w = obs.type === 'ship_block_top' ? bs * 2 : bs;
      const h = (obs.oy || 3) * bs;
      ctx.fillStyle = theme.block;
      ctx.fillRect(x, 0, w, h);
      ctx.strokeStyle = theme.accent;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(x, 0, w, h);
      // Spikes at bottom
      for (let i = 0; i < w / bs; i++) {
        ctx.fillStyle = theme.spike;
        ctx.beginPath();
        ctx.moveTo(x + i * bs, h);
        ctx.lineTo(x + i * bs + bs / 2, h + bs * 0.6);
        ctx.lineTo(x + (i + 1) * bs, h);
        ctx.closePath();
        ctx.fill();
      }
      break;
    }

    case 'ship_block_bottom':
    case 'wave_floor': {
      const x = screenX;
      const w = obs.type === 'ship_block_bottom' ? bs * 2 : bs;
      const h = bs * 2 + (obs.oy || 0) * bs;
      const y = groundY - h + 80;
      ctx.fillStyle = theme.block;
      ctx.fillRect(x, y, w, h + 80);
      ctx.strokeStyle = theme.accent;
      ctx.lineWidth = 1.5;
      ctx.strokeRect(x, y, w, h);
      // Spikes at top
      for (let i = 0; i < w / bs; i++) {
        ctx.fillStyle = theme.spike;
        ctx.beginPath();
        ctx.moveTo(x + i * bs, y);
        ctx.lineTo(x + i * bs + bs / 2, y - bs * 0.6);
        ctx.lineTo(x + (i + 1) * bs, y);
        ctx.closePath();
        ctx.fill();
      }
      break;
    }
  }
}

function drawPortal(x, y, w, h, color1, color2) {
  const pulse = 0.7 + 0.3 * Math.sin(Date.now() * 0.006);
  // Glow
  ctx.fillStyle = color1;
  ctx.globalAlpha = 0.08 * pulse;
  ctx.fillRect(x - 10, y, w + 20, h);
  ctx.globalAlpha = 1;
  // Portal lines
  ctx.strokeStyle = color1;
  ctx.lineWidth = 3;
  ctx.shadowColor = color1;
  ctx.shadowBlur = 15 * pulse;
  ctx.beginPath();
  ctx.moveTo(x + 2, y);
  ctx.lineTo(x + 2, y + h);
  ctx.stroke();
  ctx.strokeStyle = color2;
  ctx.shadowColor = color2;
  ctx.beginPath();
  ctx.moveTo(x + w - 2, y);
  ctx.lineTo(x + w - 2, y + h);
  ctx.stroke();
  ctx.shadowBlur = 0;
  // Arrow icon
  ctx.fillStyle = '#fff';
  ctx.globalAlpha = 0.6;
  ctx.font = 'bold 20px Arial';
  ctx.textAlign = 'center';
  ctx.fillText('▶', x + w / 2, y + h / 2 + 7);
  ctx.globalAlpha = 1;
}

function drawPlayer(theme) {
  const px = canvas.width * 0.15;
  const py = player.y;

  ctx.save();
  ctx.translate(px + player.width / 2, py + player.height / 2);

  if (player.mode === 'cube') {
    ctx.rotate(player.rotation);
    // Cube body
    ctx.fillStyle = theme.player;
    ctx.shadowColor = theme.player;
    ctx.shadowBlur = 15;
    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
    ctx.shadowBlur = 0;
    // Inner square
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-player.width / 4, -player.height / 4, player.width / 2, player.height / 2);
    // Eye
    ctx.fillStyle = '#fff';
    ctx.fillRect(2, -player.height / 4 - 2, player.width / 4, player.height / 4);
    ctx.fillStyle = '#000';
    ctx.fillRect(6, -player.height / 4 + 1, player.width / 6 - 2, player.height / 5);
    // Outline
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.strokeRect(-player.width / 2, -player.height / 2, player.width, player.height);

  } else if (player.mode === 'ship') {
    ctx.rotate(player.rotation);
    // Ship body (triangle-ish)
    ctx.fillStyle = theme.player;
    ctx.shadowColor = theme.player;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.moveTo(player.width / 2, 0);
    ctx.lineTo(-player.width / 2, -player.height / 2);
    ctx.lineTo(-player.width / 3, 0);
    ctx.lineTo(-player.width / 2, player.height / 2);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Engine glow
    ctx.fillStyle = theme.accent;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.arc(-player.width / 3, 0, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;

  } else if (player.mode === 'wave') {
    ctx.rotate(player.rotation);
    // Wave dart shape
    ctx.fillStyle = theme.player;
    ctx.shadowColor = theme.player;
    ctx.shadowBlur = 15;
    ctx.beginPath();
    ctx.moveTo(player.width / 2, 0);
    ctx.lineTo(-player.width / 2, -player.height / 3);
    ctx.lineTo(-player.width / 4, 0);
    ctx.lineTo(-player.width / 2, player.height / 3);
    ctx.closePath();
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  ctx.restore();
}

// ─── Game Loop ──────────────────────────────────────────────
function gameLoop(timestamp) {
  if (!lastTimestamp) lastTimestamp = timestamp;
  const dt = Math.min(timestamp - lastTimestamp, 33.33); // Cap at ~30fps min
  lastTimestamp = timestamp;

  update(dt);
  draw();
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

// ─── Initial level diff display ─────────────────────────────
document.getElementById('level-diff').textContent = THEMES[0].difficulty + ' - ' + THEMES[0].name;
</script>
</body>
</html>
